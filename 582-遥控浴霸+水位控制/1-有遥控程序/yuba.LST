C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE YUBA
OBJECT MODULE PLACED IN yuba.OBJ
COMPILER INVOKED BY: D:\KEIL4\C51\BIN\C51.EXE yuba.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //程序头函数
   2          #include <reg52.h>
   3          //显示函数
   4          #include <display.h>
   5          //宏定义
   6          #define uint unsigned int 
   7          #define uchar unsigned char
   8           
   9          //管脚声明
  10          sbit jdq= P1^0; //加热继电器
  11          sbit shui=P1^3;//加水继电器
  12          sbit Feng = P2^6; //蜂鸣器
  13          //按键
  14          sbit Key1=P1^4;  //设置
  15          sbit Key2=P1^5;  //加
  16          sbit Key3=P1^6;  //减
  17          sbit Key4=P1^7;  //确定   
  18          sbit shang=P3^7;//上限
  19          sbit xia=P3^6;//下限
  20          
  21          sbit DQ=P2^2;                           //定义DS18B20总线I/O
  22          signed char w,bj,bjx,bjd;                               //温度值全局变量
  23          uchar c;                                //温度值全局变量
  24          bit bdata flag=0,flag_BJ,flag_off=1,que;
  25          //时间计算
  26          #define Imax 14000    //此处为晶振为11.0592时的取值, 
  27          #define Imin 8000    //如用其它频率的晶振时,
  28          #define Inum1 145    //要改变相应的取值。
  29          #define Inum2 700 
  30          #define Inum3 3000 
  31          //解码变量
  32          unsigned char Im[4]={0x00,0x00,0x00,0x00};
  33          
  34          //全局变量
  35          uchar f;
  36          unsigned char m,Tc;
  37          unsigned char IrOK;
  38          
  39          //设置变量
  40          
  41          uchar xx=29;
  42          //下限
  43          uchar sx=35;
  44          //上限
  45          int ds=0;
  46          uchar Mode=0;
  47          
  48          void delay(uint z)
  49          {
  50   1              uint i,j;
  51   1              for(i=0;i<z;i++)
  52   1              for(j=0;j<121;j++);
  53   1      }
  54          /**************************************************************************************************
  55          **************************温度工作程序*************************************************************
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 2   

  56          **************************************************************************************************/
  57          /*****延时子程序*****/
  58          void Delay_DS18B20(int num)
  59          {
  60   1        while(num--) ;
  61   1      }
  62          /*****初始化DS18B20*****/
  63          void Init_DS18B20(void)
  64          {
  65   1        unsigned char x=0;
  66   1        DQ = 1;         //DQ复位
  67   1        Delay_DS18B20(8);    //稍做延时
  68   1        DQ = 0;         //单片机将DQ拉低
  69   1        Delay_DS18B20(8);   //精确延时，大于480us
  70   1        DQ = 1;         //拉高总线
  71   1        Delay_DS18B20(14);
  72   1        x = DQ;           //稍做延时后，如果x=0则初始化成功，x=1则初始化失败
  73   1        Delay_DS18B20(20);
  74   1      }
  75          /*****读一个字节*****/
  76          unsigned char ReadOneChar(void)
  77          {
  78   1        unsigned char i=0;
  79   1        unsigned char dat = 0;
  80   1        for (i=8;i>0;i--)
  81   1        {
  82   2          DQ = 0;     // 给脉冲信号
  83   2          dat>>=1;
  84   2          DQ = 1;     // 给脉冲信号
  85   2          if(DQ)
  86   2          dat|=0x80;
  87   2          Delay_DS18B20(4);
  88   2        }
  89   1        return(dat);
  90   1      }
  91          /*****写一个字节*****/
  92          void WriteOneChar(unsigned char dat)
  93          {
  94   1        unsigned char i=0;
  95   1        for (i=8; i>0; i--)
  96   1        {
  97   2          DQ = 1;
  98   2          DQ = dat&0x10;
  99   2          Delay_DS18B20(5);
 100   2          DQ = 0;
 101   2          dat>>=1;
 102   2        }
 103   1      }
 104          /*****读取温度*****/
 105          unsigned int ReadTemperature(void)
 106          {
 107   1        unsigned char a=0;
 108   1        unsigned char b=0;
 109   1        unsigned int t=0;
 110   1        float tt=0;
 111   1        Init_DS18B20();
 112   1        WriteOneChar(0xC1);  //跳过读序号列号的操作
 113   1        WriteOneChar(0x44);  //启动温度转换
 114   1        Init_DS18B20();
 115   1        WriteOneChar(0xC1);  //跳过读序号列号的操作
 116   1        WriteOneChar(0xBE);  //读取温度寄存器
 117   1        a=ReadOneChar();     //读低8位
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 3   

 118   1        b=ReadOneChar();    //读高8位
 119   1        t=b;
 120   1        t<<=8;
 121   1        t=t|a;
 122   1        tt=t*0.00625;
 123   1        t= tt*10+0.5;     //放大10倍输出并四舍五入
 124   1        return(t);
 125   1      }
 126          
 127          
 128          /*****读取温度*****/
 129          void check_wendu(void)
 130          {
 131   1              c=ReadTemperature()-5;                          //获取温度值并减去DS18B20的温漂误差
 132   1              w=c/10;                                                 //计算得到整数位
 133   1              if(w<0){w=0;}                                   //设置温度显示上限
 134   1              if(w>99){w=99;}                                 //设置温度显示上限    
 135   1      }
 136          /**************************************************************************************************
 137          ***************************************************************************************************
 138          **************************************************************************************************/
 139          
 140          
 141          /**************************************************************************************************
 142          ************************************按键工作程序***************************************************
 143          **************************************************************************************************/
 144          void Key()
 145          {
 146   1              //模式选择
 147   1              if(Key1==0)
 148   1              {
 149   2                      while(Key1==0);
 150   2                      Feng=0;
 151   2                      Mode++;
 152   2                      Display_wd();
 153   2                      if(Mode==4)
 154   2                      {
 155   3                              Mode=1;
 156   3                              Feng=1;
 157   3                      }
 158   2                      write_com(0x38);//屏幕初始化
 159   2                      write_com(0x0d);//打开显示 无光标 光标闪烁
 160   2                      write_com(0x06);//当读或写一个字符是指针后一一位
 161   2                      switch(Mode)
 162   2                      {
 163   3                              case 1:
 164   3                              {
 165   4                                      write_com(0x80+15);//位置
 166   4                                      Feng=1;
 167   4                                      break;
 168   4                              }
 169   3                              case 2:
 170   3                              {
 171   4                                      write_com(0x80+0x40+5);//位置
 172   4                                      Feng=1;
 173   4                                      break;
 174   4                              }
 175   3                              case 3:
 176   3                              {
 177   4                                      write_com(0x80+0x40+14);//位置
 178   4                                      Feng=1;
 179   4                                      break;
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 4   

 180   4                              }
 181   3                      }
 182   2              }
 183   1              if(Key2==0&&Mode!=0)
 184   1              {
 185   2                      while(Key2==0);
 186   2                      Feng=0;
 187   2                      switch(Mode)
 188   2                      {
 189   3                              case 1:
 190   3                              {
 191   4                                      if(ds<999)
 192   4                                      {
 193   5                                              ds++;
 194   5                                              write_com(0x80+13);
 195   5                                              write_data('0'+ds/100);
 196   5                                              write_data('0'+ds/10%10);
 197   5                                              write_data('0'+ds%10);
 198   5                                              write_com(0x80+15);//位置
 199   5                                      }
 200   4                                      Feng=1;
 201   4                                      break;
 202   4                              }
 203   3                              case 2:
 204   3                              {
 205   4                                      if(sx<99-1)
 206   4                                      {
 207   5                                              sx++;
 208   5                                              write_com(0x80+0x40+4);
 209   5                                              write_data('0'+sx/10%10);
 210   5                                              write_data('0'+sx%10);
 211   5                                              write_com(0x80+0x40+5);//位置
 212   5                                      }
 213   4                                      Feng=1;
 214   4                                      break;                          
 215   4                              }
 216   3                              case 3:
 217   3                              {
 218   4                                      if(xx<sx-1)
 219   4                                      {
 220   5                                              xx++;
 221   5                                              write_com(0x80+0x40+13);
 222   5                                              write_data('0'+xx/10%10);
 223   5                                              write_data('0'+xx%10);
 224   5                                              write_com(0x80+0x40+14);//位置
 225   5                                      }
 226   4                                      Feng=1;
 227   4                                      break;                          
 228   4                              }               
 229   3                      }
 230   2              }
 231   1              if(Key3==0&&Mode!=0)
 232   1              {
 233   2                      while(Key3==0);
 234   2                      Feng=0;
 235   2                      switch(Mode)
 236   2                      {
 237   3                              case 1:
 238   3                              {
 239   4                                      if(ds>0)
 240   4                                      {
 241   5                                              ds--;
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 5   

 242   5                                              write_com(0x80+13);
 243   5                                              write_data('0'+ds/100);
 244   5                                              write_data('0'+ds/10%10);
 245   5                                              write_data('0'+ds%10);
 246   5                                              write_com(0x80+15);//位置
 247   5                                      }
 248   4                                      Feng=1;
 249   4                                      break;
 250   4                              }
 251   3                              case 2:
 252   3                              {
 253   4                                      if(sx>xx+1)
 254   4                                      {
 255   5                                              sx--;
 256   5                                              write_com(0x80+0x40+4);
 257   5                                              write_data('0'+sx/10%10);
 258   5                                              write_data('0'+sx%10);
 259   5                                              write_com(0x80+0x40+5);//位置
 260   5                                      }
 261   4                                      Feng=1;
 262   4                                      break;                          
 263   4                              }
 264   3                              case 3:
 265   3                              {
 266   4                                      if(xx>0)
 267   4                                      {
 268   5                                              xx--;
 269   5                                              write_com(0x80+0x40+13);
 270   5                                              write_data('0'+xx/10%10);
 271   5                                              write_data('0'+xx%10);
 272   5                                              write_com(0x80+0x40+14);//位置
 273   5                                      }
 274   4                                      Feng=1;
 275   4                                      break;                          
 276   4                              }               
 277   3                      }
 278   2              }
 279   1              if(Key4==0)
 280   1              {
 281   2                      while(Key4==0);
 282   2                      Feng=0;
 283   2                      Mode=0;
 284   2              //      write_com(0x38);//屏幕初始化
 285   2              //      write_com(0x0c);//打开显示 无光标 无光标闪烁
 286   2                      Init1602();
 287   2                      if(ds>0)
 288   2                      {
 289   3                              flag=1;
 290   3                              jdq=1;
 291   3                              TR1=1;
 292   3                      }
 293   2                      Feng=1;
 294   2              }
 295   1                      if(IrOK==1) 
 296   1                      {
 297   2                              if(Im[2]==0x0d) //遥控设置键
 298   2                              {
 299   3                                      Feng=0;
 300   3                                      Mode++;
 301   3                                      Display_wd();
 302   3                                      if(Mode==4)
 303   3                                      {
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 6   

 304   4                                              Mode=1;
 305   4                                              Feng=1;
 306   4                                      }
 307   3                                      write_com(0x38);//屏幕初始化
 308   3                                      write_com(0x0d);//打开显示 无光标 光标闪烁
 309   3                                      write_com(0x06);//当读或写一个字符是指针后一一位
 310   3                                      switch(Mode)
 311   3                                      {
 312   4                                              case 1:
 313   4                                              {
 314   5                                                      write_com(0x80+15);//位置
 315   5                                                      Feng=1;
 316   5                                                      break;
 317   5                                              }
 318   4                                              case 2:
 319   4                                              {
 320   5                                                      write_com(0x80+0x40+5);//位置
 321   5                                                      Feng=1;
 322   5                                                      break;
 323   5                                              }
 324   4                                              case 3:
 325   4                                              {
 326   5                                                      write_com(0x80+0x40+14);//位置
 327   5                                                      Feng=1;
 328   5                                                      break;
 329   5                                              }
 330   4                                      }                                
 331   3                              }
 332   2                              //+键
 333   2                              else if(Im[2]==0x40)
 334   2                              {
 335   3                                      if(Mode!=0)
 336   3                                      {
 337   4                                              Feng=0;
 338   4                                              switch(Mode)
 339   4                                              {
 340   5                                                      case 1:
 341   5                                                      {
 342   6                                                              if(ds<999)
 343   6                                                              {
 344   7                                                                      ds++;
 345   7                                                                      write_com(0x80+13);
 346   7                                                                      write_data('0'+ds/100);
 347   7                                                                      write_data('0'+ds/10%10);
 348   7                                                                      write_data('0'+ds%10);
 349   7                                                                      write_com(0x80+15);//位置
 350   7                                                              }
 351   6                                                              Feng=1;
 352   6                                                              break;
 353   6                                                      }
 354   5                                                      case 2:
 355   5                                                      {
 356   6                                                              if(sx<99-1)
 357   6                                                              {
 358   7                                                                      sx++;
 359   7                                                                      write_com(0x80+0x40+4);
 360   7                                                                      write_data('0'+sx/10%10);
 361   7                                                                      write_data('0'+sx%10);
 362   7                                                                      write_com(0x80+0x40+5);//位置
 363   7                                                              }
 364   6                                                              Feng=1;
 365   6                                                              break;                          
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 7   

 366   6                                                      }
 367   5                                                      case 3:
 368   5                                                      {
 369   6                                                              if(xx<sx-1)
 370   6                                                              {
 371   7                                                                      xx++;
 372   7                                                                      write_com(0x80+0x40+13);
 373   7                                                                      write_data('0'+xx/10%10);
 374   7                                                                      write_data('0'+xx%10);
 375   7                                                                      write_com(0x80+0x40+14);//位置
 376   7                                                              }
 377   6                                                              Feng=1;
 378   6                                                              break;                          
 379   6                                                      }               
 380   5                                              }
 381   4                                      }
 382   3                              }
 383   2                              //-键
 384   2                              else if(Im[2]==0x19)
 385   2                              {
 386   3                                      if(Mode!=0)
 387   3                                      {
 388   4                                              Feng=0;
 389   4                                              switch(Mode)
 390   4                                              {
 391   5                                                      case 1:
 392   5                                                      {
 393   6                                                              if(ds>0)
 394   6                                                              {
 395   7                                                                      ds--;
 396   7                                                                      write_com(0x80+13);
 397   7                                                                      write_data('0'+ds/100);
 398   7                                                                      write_data('0'+ds/10%10);
 399   7                                                                      write_data('0'+ds%10);
 400   7                                                                      write_com(0x80+15);//位置
 401   7                                                              }
 402   6                                                              Feng=1;
 403   6                                                              break;
 404   6                                                      }
 405   5                                                      case 2:
 406   5                                                      {
 407   6                                                              if(sx>xx+1)
 408   6                                                              {
 409   7                                                                      sx--;
 410   7                                                                      write_com(0x80+0x40+4);
 411   7                                                                      write_data('0'+sx/10%10);
 412   7                                                                      write_data('0'+sx%10);
 413   7                                                                      write_com(0x80+0x40+5);//位置
 414   7                                                              }
 415   6                                                              Feng=1;
 416   6                                                              break;                          
 417   6                                                      }
 418   5                                                      case 3:
 419   5                                                      {
 420   6                                                              if(xx>0)
 421   6                                                              {
 422   7                                                                      xx--;
 423   7                                                                      write_com(0x80+0x40+13);
 424   7                                                                      write_data('0'+xx/10%10);
 425   7                                                                      write_data('0'+xx%10);
 426   7                                                                      write_com(0x80+0x40+14);//位置
 427   7                                                              }
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 8   

 428   6                                                              Feng=1;
 429   6                                                              break;                          
 430   6                                                      }               
 431   5                                              }
 432   4                                      }
 433   3                              }
 434   2                              //确定键
 435   2                              else if(Im[2]==0x15)
 436   2                              {
 437   3                                      Feng=0;
 438   3                                      Mode=0;
 439   3                                      Init1602();
 440   3                                      if(ds>0)
 441   3                                      {
 442   4                                              flag=1;
 443   4                                              jdq=1;
 444   4                                              TR1=1;
 445   4                                      }
 446   3                                      Feng=1;
 447   3                              } 
 448   2                              IrOK=0;   
 449   2                      }
 450   1      }
 451          /**************************************************************************************************
 452          ***************************************************************************************************
 453          **************************************************************************************************/
 454          
 455          
 456          
 457          /**************************************************************************************************
 458          ************************************报警部分程序***************************************************
 459          **************************************************************************************************/
 460          void Alam()
 461          {
 462   1              if(flag_BJ==1&&flag_off==1)
 463   1              {
 464   2                      Feng=0;
 465   2                      delay(1000);
 466   2                      Feng=1;
 467   2                      flag_off=0;
 468   2      //              flag_BJ=0;
 469   2              }
 470   1      }
 471          /**************************************************************************************************
 472          ***************************************************************************************************
 473          **************************************************************************************************/
 474          
 475          /**************************************************************************************************
 476          *********************************************主程序************************************************
 477          **************************************************************************************************/
 478          void main()
 479          {
 480   1              Init1602();
 481   1              EA=1;//打开中断总开关
 482   1              IT1=1;//下降沿有效
 483   1              EX1=1;//外部中断1开
 484   1              ET1=1;//打开允许开关
 485   1              TMOD=0x01;//设置工作方式
 486   1              TL1=0x3c;
 487   1              TH1=0xb0;//赋初值
 488   1              TH0=0;//T0赋初值
 489   1              TL0=0;
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 9   

 490   1              TR0=0;//t0开始计时
 491   1              check_wendu();
 492   1              delay(1000);
 493   1              bjd=99;
 494   1              bjx=0;                           //这两个变量的作用就是，防止温度大范围跳动造成加热设备误动作
 495   1              while(1)
 496   1              {       
 497   2                      check_wendu();
 498   2                      if(Mode==0)
 499   2                      {       
 500   3                              Display_1602(c,ds,sx,xx);
 501   3                              if((xia==1)&&(shang==1)) //低于下限
 502   3                              {
 503   4                                      que=1;
 504   4                                      shui=0;
 505   4                                      jdq=1;
 506   4                              }
 507   3                              else
 508   3                              {
 509   4                                      que=0;
 510   4                              }
 511   3                              if((shang==0)&&(xia==0)) //高于上限
 512   3                              {
 513   4                                      shui=1;
 514   4                                      if(flag_BJ==0)
 515   4                                      flag_BJ=1;
 516   4                              }
 517   3                              if((shang==0)&&(xia==1)) //错误
 518   3                              {
 519   4                                      shui=1;
 520   4                                      jdq=1;
 521   4                                      Feng=0;
 522   4                                      que=1;
 523   4                              }
 524   3                              if(flag==0)
 525   3                              {
 526   4                                      if((w<bjd)&&(w>bjx))
 527   4                                      {
 528   5                                              if(w>=sx)
 529   5                                              {
 530   6                                                      jdq=1;
 531   6                                                      if(flag_BJ==0)
 532   6                                                      flag_BJ=1;
 533   6                                              }
 534   5                                              else if((w<xx)&&(que==0))         
 535   5                                              {
 536   6                                                      jdq=0;
 537   6                                                      if(flag_BJ==0)
 538   6                                                      flag_BJ=1;
 539   6                                              }
 540   5                                              else
 541   5                                              {
 542   6                                                      flag_BJ=0;
 543   6                                                      flag_off=1;
 544   6                                              }
 545   5                                              bjd=w+5;
 546   5                                              bjx=w-5;
 547   5                                      }
 548   4                              }
 549   3                      }
 550   2                      Key();
 551   2                      Alam();
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 10  

 552   2              }
 553   1      }
 554          /**************************************************************************************************
 555          ***************************************************************************************************
 556          **************************************************************************************************/
 557          
 558          
 559          /**************************************************************************************************
 560          ****************************************定时器工作程序*********************************************
 561          **************************************************************************************************/
 562          void time1() interrupt 3//定时器函数
 563          {
 564   1              uint s;
 565   1              TH1=0x3c;
 566   1              TL1=0xb0;//重新赋初值
 567   1              s++;
 568   1              if(s==1200)     //s=20为1s钟  1200为1分钟
 569   1              {
 570   2                      s=0;
 571   2                      ds--;
 572   2                      if(ds==0)
 573   2                      {
 574   3                              flag=0;
 575   3                              if(w>=sx)
 576   3                              {
 577   4                                      jdq=1;
 578   4                                      if(flag_BJ==0)
 579   4                                      flag_BJ=1;
 580   4                              }
 581   3                              else if((w<xx)&&(que==0))
 582   3                              {
 583   4                                      jdq=0;
 584   4                                      if(flag_BJ==0)
 585   4                                      flag_BJ=1;
 586   4                              }
 587   3                              else
 588   3                                      {
 589   4                                              flag_BJ=0;
 590   4                                              flag_off=1;
 591   4                                      }
 592   3                              bjd=w+10;
 593   3                              bjx=w-10;
 594   3                              TR1=0;
 595   3                      }
 596   2              }
 597   1      }
 598          /**************************************************************************************************
 599          ***************************************************************************************************
 600          **************************************************************************************************/
 601          
 602          
 603          /**************************************************************************************************
 604          *************************************红外解码定时器程序********************************************
 605          **************************************************************************************************/
 606          //外部中断解码程序_外部中断0
 607          void intersvr1(void) interrupt 2 using 1
 608          {
 609   1       TR0=1;
 610   1       Tc=TH0*256+TL0;//提取中断时间间隔时长
 611   1       TH0=0; 
 612   1       TL0=0;         //定时中断重新置零
 613   1      
C51 COMPILER V9.00   YUBA                                                                  09/19/2015 20:40:49 PAGE 11  

 614   1       if((Tc>Imin)&&(Tc<Imax))
 615   1       { 
 616   2              m=0;
 617   2              f=1;
 618   2              return;
 619   2       }       //找到启始码
 620   1       if(f==1)
 621   1       {
 622   2              if(Tc>Inum1&&Tc<Inum3) 
 623   2          {
 624   3              Im[m/8]=Im[m/8]>>1|0x80; m++; 
 625   3          }
 626   2          if(Tc>Inum2&&Tc<Inum1) 
 627   2          {
 628   3            Im[m/8]=Im[m/8]>>1; m++; //取码
 629   3               }
 630   2               if(m==32) 
 631   2          {
 632   3            m=0;  
 633   3            f=0;
 634   3            if(Im[2]==~Im[3]) 
 635   3            {
 636   4                 IrOK=1;
 637   4                                TR0=0; 
 638   4              }
 639   3            else IrOK=0;   //取码完成后判断读码是否正确
 640   3          }
 641   2                     //准备读下一码
 642   2       }
 643   1      }
 644          /**************************************************************************************************
 645          ***************************************************************************************************
 646          **************************************************************************************************/
 647          
 648          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2076    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
